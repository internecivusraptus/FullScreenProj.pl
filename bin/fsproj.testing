#!/usr/bin/env perl

use strict;
use warnings;
use threads;
use Thread::Queue;
#use sigtrap 'handler' => \&Config::daemonize, 'HUP';
#use sigtrap 'handler' => \&exit, 'HUP';

our $VERSION = 0.03;
our $TITLE =
"Crazy Fullscreen Detector & Screensaver Disabler\nVersion: $VERSION;\n\nCopyright Â© 2012, Igor Gritsenko.
\n=================\n";
our %settings = ();
our $TQWinID  = Thread::Queue->new();
our $TQScrSvr = Thread::Queue->new();

package Config;
use File::HomeDir;
use POSIX ('setsid');

my $home     = &home();
my $conffile = "$home/.config/FullscreenProj.pl/fsproj.conf";

sub readconf {
    if ( -e $conffile ) {
        open CONFIG, $conffile;
        while (<CONFIG>) {
            chomp;
            next if s/^(#.*|\s*)$//;
            my ( $var, $value ) = split( /\s*=\s*/, $_, 2 );
            $settings{$var} = $value;
        }
    }
    else {
        $settings{regex}   = qr/(libflash)|(vlc)|(mplayer)/;
        $settings{timeout} = 50;
        $settings{GUI}     = 0;
        $settings{state}   = 0;
        $settings{action}  = "start";
        &writeconf;
    }
}

sub writeconf {
    $settings{action} = "start";
    mkdir $conffile =~ s/fsproj.conf//r;
    open CONFIG, ">", $conffile;
    foreach ( keys %settings ) {
        print CONFIG "$_ = $settings{$_}\n";
    }
    close CONFIG;
}

sub daemonize {
    die "Can't chdir to /: $!" unless chdir '/';
    umask 0;

    #    die "Can't read /dev/null: $!"     unless open STDIN,  '/dev/null';
    #    die "Can't write to /dev/null: $!" unless open STDOUT, '>/dev/null';
    #    die "Can't write to /dev/null: $!" unless open STDERR, '>/dev/null';
    die "Can't fork: $!" unless defined( my $pid = fork );
    exit if $pid;
    &Config::readconf;
    die "Can't start a new session: $!" unless setsid();
}

sub FSProcHandle {
    my ( $proc, $action ) = @_;

}

sub FSPlist {
    my $regexes = $settings{regex} =~ s/[\(\)\:\^\?]//gr;
    my @regexes = split( /\|/, $regexes );
    print "We are currently tracking such processes:\n\n";
    foreach (@regexes) {
        print "\t\t\t$_\n";
    }
    print "\n";
    exit;
}

sub FSHelp {
    print <<EOF;

Usage: fsproj [some options] <start|stop>

  Actions: 
start          Starts the script, if not started yet, and  sets the specified options.
stop           Stops the script. All parameters will be ignored.

If script runs without action, it suggests that user wanted to start.

  Options:
--help                  This help text.
--no-gui                Do not use the GUI (Default).
--gui                   Enable WxWidgets GUI (Not implemented yet).
--timeout sec           Set timeout in seconds.
--disable               Start script only, don't allow anything to do. (Not implemented yet).
--enable                Start script and let him do work (Default). (Not implemented yet).
--process-list          Show current process checking list.
--add-proc process      Add process for tracking (Not implemented yet).
--del-proc process      Delete process from tracking (Not implemented yet).

EOF
    exit;

}

sub ARGVparse {
    $settings{action} =
      ( $ARGV[-1] eq "start" || $ARGV[-1] eq "stop" ) ? pop @ARGV : "start";
    while (@ARGV) {
        my $param = shift @ARGV;
        if ( $param =~ s/^--// ) {
            &FSHelp  if $param eq "help";
            &FSPlist if $param eq "process-list";
            if ( $param eq "timeout" ) {
                $_ = shift @ARGV;
                if ( $_ =~ /\d+/ ) {
                    $settings{$param} = $_;
                }
                else {
                    unshift @ARGV, $_;
                }
                next;
            }
            if ( $param eq "no-gui" ) {
                $settings{GUI} = 0;
                next;
            }
            if ( $param eq "gui" ) {
                $settings{GUI} = 1;
                next;
            }

            if ( $param eq "disable" ) {
                $settings{state} = 0;
                next;
            }
            if ( $param eq "enable" ) {
                $settings{state} = 1;
                next;
            }
            print "I don't know anything about --$param, try --help\n";
            exit;
        }

    }
    return $settings{action} eq "start";
}

1;

package Logic;
use Net::DBus;
use Proc::ProcessTable;
$| = 1;
my $ON  = 'xset +dpms';
my $OFF = 'xset -dpms';

sub ScreenSaver {
    my $command;
    foreach ( @{ 'Proc::ProcessTable'->new->table; } ) {
        if ( $_->cmndline =~ /xscreensaver/ ) {
            $command = qq(system "xscreensaver-command -deactivate");
        }

        elsif ( $_->cmndline =~ /krunner/ ) {
            $command =
qq(Net::DBus->session->get_service("org.freedesktop.ScreenSaver")->get_object('/ScreenSaver')->SimulateUserActivity());
        }

        elsif ( $_->cmndline =~ /gnome-screensaver/ ) {
            $command =
qq(Net::DBus->session->get_service("org.gnome.ScreenSaver")->get_object('/')->SimulateUserActivity());
        }
    }
    return sub {
        while (1) {
            my $timeout=$settings{timeout};
            if ( $TQScrSvr->pending ) {
                $timeout=$TQScrSvr->peek();
                eval $command;
                if ($@) { warn $@; }
            }
            print $timeout;
            sleep $timeout;
        }
      }
}

sub CheckDPMS {
    my $DPMSPhrase = "DPMS is";
    chomp( my $state =
          ( qx|xset q \| grep "$DPMSPhrase" | =~ s/^\s+$DPMSPhrase\s+//r ) );
    return $state eq "Enabled";
}

sub ProjLoop {
    my $DPMSstate = &CheckDPMS;
    my @processes;
    while (1) {
        my ($winid) = $TQWinID->peek;
        while ( $TQWinID->pending() ) {
            $TQWinID->dequeue();
        }

        while ( !$TQWinID->pending() ) {

            @processes = ();
            foreach ( @{ 'Proc::ProcessTable'->new->table; } ) {
                if ( $_->cmndline =~ /$settings{regex}/ ) {
                    push @processes, $_->pid;
                }
            }
            if ( ( qx#xprop -id $winid _NET_WM_PID# =~ s/[^\d]+//r ) ~~
                @processes
                and qx|xprop -id $winid _NET_WM_STATE| =~
                /_NET_WM_STATE_FULLSCREEN/ )
            {
                $TQScrSvr->enqueue( $settings{timeout} );
                system $OFF;
            }
            else {
                while ( $TQScrSvr->pending() ) {
                    $TQScrSvr->dequeue();
                }

                system $ON if $DPMSstate;
            }
            sleep $settings{timeout};
        }
    }
    close XPROP;
}

sub XWinID {
    open XPROP, 'xprop -spy -root _NET_ACTIVE_WINDOW |';
    while (<XPROP>) {
        my $winid = s/.*?\# (.*)/$1/r;
        chomp $winid;
        $TQWinID->enqueue($winid);
    }
}

1;

package FSProj;

sub ActionHandle {
    my ( $signal, $pid ) = @_;
    print "$signal fsproj PID:$pid\n";
    &Config::writeconf();
    kill $signal => $pid;
}

sub RunMainLoop {
    &Config::daemonize;
    threads->create( \&Logic::XWinID )->detach();
    threads->create(&Logic::ScreenSaver)->detach();
    threads->create( \&Logic::ProjLoop )->join();
}

print $TITLE;
$settings{action} = "start";
$settings{state}  = 1;
$settings{GUI}    = 0;

if ( defined @ARGV ) {
    &Config::readconf();
    &Config::writeconf if &Config::ARGVparse();

}
print "$settings{timeout}\n";
foreach ( @{ 'Proc::ProcessTable'->new->table; } ) {
    if ( ( $_->cmndline =~ /perl.*fsproj/ ) and ( $_->pid != $$ ) ) {
        my $sig =
            $settings{action} eq "stop"  ? 'KILL'
          : $settings{action} eq "start" ? 'HUP'
          :                                0;
        &FSProj::ActionHandle( $sig, $_->pid );
        exit;
    }
}
exit if $settings{action} ne "start";
&FSProj::RunMainLoop();
