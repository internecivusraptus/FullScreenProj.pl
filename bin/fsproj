#!/usr/bin/env perl

use strict;
use warnings;
use threads;
use Thread::Queue;
use sigtrap 'handler' => \&Config::daemonize, 'HUP';

our $VERSION      = 0.03;
our $TITLE = "Crazy Fullscreen Detector & Screensaver Disabler\nVersion: $VERSION;\n\nCopyright (C) 2012, Igor Gritsenko.\n=================\n";
our %settings     = ();
our $TQWinID      = Thread::Queue->new();
our $TQScrSvr     = Thread::Queue->new();
our $TQStopSignal = Thread::Queue->new();

package Config;
use File::HomeDir;
use POSIX ('setsid');

my $home     = &home();
my $conffile = "$home/.config/FullscreenProj.pl/fsproj.conf";

sub readconf {
    if ( -e $conffile ) {
        open CONFIG, $conffile;
        while (<CONFIG>) {
            chomp;
            next if s/^(#.*|\s*)$//;
            my ( $var, $value ) = split( /\s*=\s*/, $_, 2 );
            $settings{$var} = $value;
        }
    }
    else {
        $settings{regex}   = qr/(libflash)|(vlc)|(mplayer)/;
        $settings{timeout} = 50;
        $settings{GUI}     = 0;
        $settings{state}   = 1;
        $settings{action}  = "start";
        &writeconf;
    }
}

sub writeconf {
    $settings{action} = "start";
    mkdir $conffile =~ s/fsproj.conf//r;
    open CONFIG, ">", $conffile;
    foreach ( keys %settings ) {
        print CONFIG "$_ = $settings{$_}\n";
    }
    close CONFIG;
}

sub daemonize {
    &Config::writeconf();
    die "Can't chdir to /: $!" unless chdir '/';
    umask 0;

    #    die "Can't read /dev/null: $!"     unless open STDIN,  '/dev/null';
    #    die "Can't write to /dev/null: $!" unless open STDOUT, '>/dev/null';
    #    die "Can't write to /dev/null: $!" unless open STDERR, '>/dev/null';
    die "Can't fork: $!" unless defined( my $pid = fork );
    exit if $pid;
    die "Can't start a new session: $!" unless setsid();
}

sub FSPlist {
    my $regexes = $settings{regex} =~ s/[\(\)\:\^?]//gr;
    my @regexes = split( /\|/, $regexes );
    print $TITLE;
    print "We are currently tracking such processes:\n\n";
    foreach (@regexes) {
        print "\t\t\t$_\n";
    }
    print "\n";
    exit;
}

sub FSHelp {
    print <<EOF;

$TITLE

Usage: fsproj [some options] <start|stop>

  Actions: 
start          Starts the script, if not started yet, and  sets the specified options.
stop           Stops the script. All parameters will be ignored.

If script runs without action, it suggests that user wanted to start.

  Options:
--help                  This help text.
--no-gui                Do not use the GUI (Default).
--gui                   Enable WxWidgets GUI.
--timeout sec           Set timeout in seconds.
--disable               Start script only, don't allow anything to do.
--enable                Start script and let him do work (Default).
--process-list          Show current process checking list.
--add-process process   Not implemented yet.
--del-process process   Not implemented yet.

EOF
    exit;

}

sub ARGVparse {
    $settings{action} =
      ( $ARGV[-1] eq "start" || $ARGV[-1] eq "stop" ) ? pop @ARGV : "start";
    while (@ARGV) {
        my $param = shift @ARGV;
        if ( $param =~ s/^--// ) {
            &FSHelp  if $param eq "help";
            &FSPlist if $param eq "process-list";
            if ( $param eq "timeout" ) {
                $_ = shift @ARGV;
                if ( $_ !~ /\d+/ ) {
                    unshift @ARGV, $_;
                    $_ = 50;
                }
                $settings{$param} = $_;

                next;
            }
            if ( $param eq "no-gui" ) {
                $settings{GUI} = 0;
                next;
            }
            if ( $param eq "gui" ) {
                $settings{GUI} = 1;
                next;
            }

            if ( $param eq "disable" ) {
                $settings{state} = 0;
                next;
            }
            if ( $param eq "enable" ) {
                $settings{state} = 1;
                next;
            }

        }

    }
}

1;

package Logic;
use Net::DBus;
use Proc::ProcessTable;
$| = 1;
my $ON  = 'xset +dpms';
my $OFF = 'xset -dpms';

sub ScreenSaver {
    my $command;
    foreach ( @{ 'Proc::ProcessTable'->new->table; } ) {
        if ( $_->cmndline =~ /xscreensaver/ ) {
            $command = qq(system "xscreensaver-command -deactivate");
        }

        elsif ( $_->cmndline =~ /krunner/ ) {
            $command =
qq(Net::DBus->session->get_service("org.freedesktop.ScreenSaver")->get_object('/ScreenSaver')->SimulateUserActivity());
        }

        elsif ( $_->cmndline =~ /gnome-screensaver/ ) {
            $command =
qq(Net::DBus->session->get_service("org.gnome.ScreenSaver")->get_object('/')->SimulateUserActivity());
        }
    }
    return sub {
        my $timeout = $settings{timeout};
        while ( $TQStopSignal->pending ) {
            if ( $TQScrSvr->pending ) {
                eval $command;
                if ($@) { warn $@; }
            }
            print $settings{timeout};
            sleep $settings{timeout};
        }
      }
}

sub CheckDPMS {
    my $DPMSPhrase = "DPMS is";
    chomp( my $state =
          ( qx|xset q \| grep "$DPMSPhrase" | =~ s/^\s+$DPMSPhrase\s+//r ) );
    return $state eq "Enabled";
}

sub ProjLoop {
    my $DPMSstate = &CheckDPMS;
    my @processes;
    while ( $TQStopSignal->pending ) {
        my ($winid) = $TQWinID->extract( -1, 1 );
        while ( $TQWinID->pending() ) {
            $TQWinID->dequeue();
        }

        while ( !$TQWinID->pending() ) {

            #exit unless $TQStopSignal->pending;
            @processes = ();
            foreach ( @{ 'Proc::ProcessTable'->new->table; } ) {
                if ( $_->cmndline =~ /$settings{regex}/ ) {
                    push @processes, $_->pid;
                }
            }
            if ( ( qx#xprop -id $winid _NET_WM_PID# =~ s/[^\d]+//r ) ~~
                @processes
                and qx|xprop -id $winid _NET_WM_STATE| =~
                /_NET_WM_STATE_FULLSCREEN/ )
            {
                $TQScrSvr->enqueue( $settings{timeout} );
                system $OFF;
            }
            else {
                while ( $TQScrSvr->pending() ) {
                    $TQScrSvr->dequeue();
                }

                system $ON if $DPMSstate;
            }
            sleep $settings{timeout};
        }
    }
    close XPROP;
}

sub XWinID {
    open XPROP, 'xprop -spy -root _NET_ACTIVE_WINDOW |';
    while (<XPROP>) {
        my $winid = s/.*?\# (.*)/$1/r;
        chomp $winid;
        $TQWinID->enqueue($winid);
    }
}

1;

package FSProj;

sub ActionHandle {
    my ( $signal, $pid ) = @_;
    kill $signal => $pid;
}

sub RunMainLoop {
    &Config::daemonize;
    threads->create( \&Logic::XWinID )->detach();
    threads->create(&Logic::ScreenSaver)->detach();
    threads->create( \&Logic::ProjLoop )->join();
}

&Config::readconf();
if ( defined @ARGV ) {
    &Config::ARGVparse();
}
foreach ( @{ 'Proc::ProcessTable'->new->table; } ) {
    if ( ( $_->cmndline =~ /perl.*fsproj/ ) and ( $_->pid != $$ ) ) {
        my $sig =
            $settings{action} eq "stop"  ? 'KILL'
          : $settings{action} eq "start" ? 'HUP'
          :                                0;
        &FSProj::ActionHandle( $sig, $_->pid );
        exit;
    }
}
exit if $settings{action} ne "start";
$TQStopSignal->enqueue(1);
&FSProj::RunMainLoop();
