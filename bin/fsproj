#!/usr/bin/env perl
=pod

=head1 NAME

fsproj - Crazy Fullscreen Detector & Screensaver Disabler

=head1 AUTHOR

Igor Gritsenko <xenomorph@mail.univ.kiev.ua>

=head1 COPYRIGHT

Copyright (c) 2012 Igor Gritsenko <xenomorph@mail.univ.kiev.ua>

This program is free software; you can redistribute it and/or
                modify it under the same terms as Perl itself.

=cut

use v5.10;
use threads ( 'exit' => 'threads_only' );
use threads::shared;
use Thread::Queue;
use Proc::ProcessTable;
use Cwd qw/abs_path/;

our $VERSION  = 0.7;
our %settings = ();
our $TQWinID  = Thread::Queue->new();
our $TQScrSvr = Thread::Queue->new();
our $TQEnable = Thread::Queue->new();
our $thispath = Cwd::abs_path($0) =~ s/(.*)\/.*\/.*/$1/r;
our $DEBUG    = 0;
our $EXIT :shared;
$EXIT = 0;
$|    = 1;

package FSProj::Utils;
use POSIX ('setsid');

sub FSDebug {
    print shift if $DEBUG;
}

sub regexp2array {
    my ( $inp_reg, $retval ) = @_;
    @$retval = split( /\|/, $$inp_reg =~ s/[\(\)\:\^\?]//gr );
    undef $retval;
    undef $inp_reg;
}

sub array2regexp {
    my ( $ref_arr, $ret_val ) = @_;
    $$ret_val = "(?^:(" . join( ')|(', @$ref_arr ) . "))";
    undef $ret_val;
    undef $ref_arr;
}

sub processlist {
    my ( $cmndline, $retval ) = @_;
    foreach ( @{ 'Proc::ProcessTable'->new->table; } ) {
        if ( $_->cmndline =~ $cmndline ) {
            push @$retval, $_->pid;
        }
    }
    undef $_;
    undef $cmndline;
    undef $retval;
}

sub daemonize {
    die "Can't chdir to /: $!" unless chdir '/';
    umask 0;

    die "Can't read /dev/null: $!"     unless open STDIN,  '/dev/null';
    die "Can't write to /dev/null: $!" unless open STDOUT, '>/dev/null';
    die "Can't write to /dev/null: $!" unless open STDERR, '>/dev/null';
    die "Can't fork: $!" unless defined( my $pid = fork );
    exit if $pid;
    die "Can't start a new session: $!" unless setsid();
    undef $pid;
}
1;

package FSProj::Config;
use File::HomeDir;
use File::Copy qw/cp/;
use Getopt::Long;
use Pod::Usage;

my $conffile =
  File::HomeDir::my_home() . "/.config/FullscreenProj.pl/fsproj.conf";

sub readconf {
    if ( -e $conffile ) {
        open CONFIG, $conffile;
        while (<CONFIG>) {
            chomp;
            next if s/^(#.*|\s*)$//;
            my ( $var, $value ) = split( /\s*=\s*/, $_, 2 );
            $settings{$var} = $value;
            undef $var;
            undef $value;
        }
        close CONFIG;
    }
    else {
        &File::Copy::cp($thispath."/share/doc/fullscreenprojpl/fsproj.conf",$conffile);
        &FSProj::Config::readconf;
    }
}

sub writeconf {
    mkdir $conffile =~ s/fsproj.conf//r;
    open CONFIG, ">", $conffile;
    foreach ( keys %settings ) {
        print CONFIG $_ . " = " . $settings{$_} . "\n";
    }
    close CONFIG;
}

sub FSProcHandle {
    my ( $aproc, $dproc, $retval ) = @_;
    my %unproc   = ();
    my @currproc = ();
    &FSProj::Utils::regexp2array( \$settings{regex}, \@currproc );
    foreach ( @currproc, @$aproc ) {
        $unproc{$_} = 1;
    }
    delete $unproc{$_} foreach (@$dproc);
    @$aproc = sort keys %unproc;
    undef %unproc;
    undef $dproc;
    &FSProj::Utils::array2regexp( $aproc, $retval );
    undef $retval;
    undef $aproc;
}

sub FSPlist {
    print "We are currently tracking such processes:\n";
    {
        my @proc;
        &FSProj::Utils::regexp2array( \$settings{regex}, \@proc );
        local $, = "\n\t";
        print "\t";
        print @proc;
        print "\n";
    }
    exit;
}

sub ARGVparse {
    &FSProj::Config::readconf();
    my %tempsets;
    my $action;
    my @dprocs = qw/start status restart stop/;
    my @aprocs;

=head1 SYNOPSIS

fsproj [options] <action>

Actions:

B<start stop restart status>

Options:

B<[--help] [--no-gui] [--gui] [--timeout seconds] [--disable] [--enable] [--process-list] [--add-proc process1 process2 process3 ...] [--del-proc process1 process2 process3 ...] [--version] [--debug]>

Use --help for more information.

=cut
    GetOptions(
        \%tempsets,
        'timeout=i',
        'gui!', 'enable',
        'add-proc=s{,}' => \@aprocs,
        'del-proc=s{,}' => \@dprocs,
        'help'          => sub {
            &Pod::Usage::pod2usage(
                -verbose  => 99,
                -sections => "NAME|SYNOPSIS|OPTIONS|ARGUMENTS"
            );
        },
        'disable' => sub { $tempsets{enable} = 0 },
        'process-list' => sub { &FSProj::Config::FSPlist },
        'debug'        => sub { $DEBUG = 1; use warnings; use diagnostics; },
        'version' =>
          sub { print "FullScreenProj.pl version: " . $VERSION . "\n"; exit; },

    );
    my @thisproc = ();
    &FSProj::Utils::processlist( qr/perl.*fsproj/, \@thisproc );
    given (@ARGV) {

        when ( "stop"    ~~ \@ARGV ) { $action = "stop"; }
        when ( "status"  ~~ \@ARGV ) { $action = "status"; }
        when ( "start"   ~~ \@ARGV ) { $action = "start"; }
        when ( "restart" ~~ \@ARGV ) { $action = "restart"; }
        default { $action = "restart"; }
    }
    if ($#thisproc) {

        foreach my $pid (@thisproc) {
            if ( $$ != $pid ) {
                given ($action) {
                    when (undef) { }
                    when (/(^start)|(status)/) {

                        print "fsproj is already running.\n";
                        print "More help: fsproj --help\n" if $_ eq "status";
                        exit;
                    }
                    when (/stop/) {
                        &FSProj::Main::ActionHandle( 'KILL', $pid );
                        exit;
                    }
                    when (/restart/) {
                        &FSProj::Main::ActionHandle( 'KILL', $pid );
                    }
                }
            }
            undef $pid;
        }

    }
    else {
        given ($action) {
            when (undef) { }
            when (/(stop)|(status)/) {
                print "fsproj is not running yet.\n";
                exit;
            }
        }
    }
    foreach ( keys %tempsets ) {
        $settings{$_} = $tempsets{$_};
    }
    undef %tempsets;
    &FSProj::Config::FSProcHandle( \@aprocs, \@dprocs, \$settings{regex} )
      if @aprocs
          or @dprocs;
    undef @aprocs;
    undef @dprocs;
    &FSProj::Config::writeconf() unless $action eq "stop";
    undef $action;
    $TQEnable->enqueue(1) if $settings{enable};
    undef @ARGV;
}

1;

package FSProj::Logic;

use Net::DBus;

sub ScreenSaver {
    my $command;
    my %cmnd_hash = (
        q[system "xscreensaver-command -deactivate"] => "xscreensaver",
q[Net::DBus->session->get_service("org.freedesktop.ScreenSaver")->get_object('/ScreenSaver')->SimulateUserActivity()]
          => "krunner",
q[Net::DBus->session->get_service("org.gnome.ScreenSaver")->get_object('/')->SimulateUserActivity()]
          => "gnome-screensaver"
    );
    while ( my ( $cmnd, $saver ) = each(%cmnd_hash) ) {
        my @array_p = ();
        &FSProj::Utils::processlist( $saver, \@array_p );
        if (@array_p) { $command = $cmnd; last; }
        undef $cmnd;
        undef $saver;
        undef @array_p;
    }
    return sub {

        if ( defined $command ) {
            FSProj::Utils::FSDebug( $command . "\n" );
            my $timeout = $settings{timeout};
            while (1) {
                last if $EXIT;
                if ( $TQScrSvr->pending ) {
                    $timeout = $TQScrSvr->peek;
                    FSProj::Utils::FSDebug(
                        "Simulating user activity: " . $command . "\n" );
                    eval $command;
                    if ($@) {
                        warn $@;
                    }
                }
                sleep $timeout;
            }
            undef $timeout;
        }
        threads->detach;
        threads->exit;
    };
    undef $command;
}

sub CheckDPMS {
    my $retval     = shift;
    my $DPMSPhrase = "DPMS is";
    chomp( my $state =
          qx|xset q \| grep "$DPMSPhrase" | =~ s/^\s+$DPMSPhrase\s+//r );
    undef $DPMSPhrase;
    $$retval = $state eq "Enabled";
    undef $retval;
}

sub ProjLoop {

    my $ON  = 'xset +dpms';
    my $OFF = 'xset -dpms';
    my $DPMSstate;
    &CheckDPMS( \$DPMSstate );
    my @processes;
    while (1) {
        last if $EXIT;
        my ($winid) = $TQWinID->dequeue;
        &FSProj::Utils::processlist( $settings{regex}, \@processes );
        FSProj::Utils::FSDebug(
            $winid . "@" . @processes . "@" . $#processes . "\n" );
        until ( $TQWinID->pending ) {
            if ( qx#xprop -id $winid _NET_WM_PID# =~ s/[^\d]+//r ~~ \@processes
                and qx|xprop -id $winid _NET_WM_STATE| =~
                /_NET_WM_STATE_FULLSCREEN/ )
            {
                FSProj::Utils::FSDebug(
                    "We've got videoplayer in fullscreen mode!\n");
                $TQScrSvr->enqueue( $settings{timeout} );
                system $OFF;
            }
            else {
                while ( $TQScrSvr->pending() ) {
                    $TQScrSvr->dequeue();
                }

                system $ON if $DPMSstate;
            }
            sleep $settings{timeout};
        }
        undef @processes;
        undef $winid;
    }
    threads->detach;
    threads->exit;
}

sub XWinID {
    open XPROP, 'xprop -spy -root _NET_ACTIVE_WINDOW |';
    my $winid_p = -1;
    while (<XPROP>) {
        last if $EXIT;
        FSProj::Utils::FSDebug($_);
        if ( $TQEnable->pending ) {
            my $winid = s/.*?\# (.*)/$1/r;
            chomp $winid;
            $TQWinID->enqueue($winid) if $winid and $winid_p ne $winid;
            $winid_p = $winid;
            undef $winid;
        }
    }
    undef $winid_p;
    close XPROP;
    threads->detach;
    threads->exit;
}
1;

package FSProj::SettingsDialog;

use Wx qw[:everything];
use base qw(Wx::Dialog);

sub new {
    my ( $self, $parent, $id, $title, $pos, $size, $style, $name ) = @_;
    $parent = undef             unless defined $parent;
    $id     = -1                unless defined $id;
    $title  = ""                unless defined $title;
    $pos    = wxDefaultPosition unless defined $pos;
    my @processes;
    &FSProj::Utils::regexp2array( \$settings{regex}, \@processes );
    my $height = 340;
    $size = [ 220, $height ];
    $name = "" unless defined $name;
    $style = wxDEFAULT_DIALOG_STYLE;
    $self =
      $self->SUPER::new( $parent, $id, $title, $pos, $size, $style, $name );
    $self->{fsenable} =
      Wx::CheckBox->new( $self, -1, "Tracking enabled", [ 27, 10 ], );
    $self->{fsenable}->SetValue( $settings{enable} );
    $self->{fsgui} =
      Wx::CheckBox->new( $self, -1, "Use WxWidgets GUI", [ 27, 36 ], );
    $self->{fsgui}->SetValue( $settings{gui} );
    $self->{tmlabel} =
      Wx::StaticText->new( $self, -1, "Timeout in seconds", [ 76, 66 ], );
    $self->{timeout} = Wx::SpinCtrl->new(
        $self, -1, "",
        [ 10, 66 ],
        [ 55, 20 ],
        wxSP_ARROW_KEYS, 0, 100, $settings{timeout}
    );
    $self->{fsprlistview} = Wx::ListView->new(
        $self, -1,
        [ 10,  90 ],
        [ 200, $height - 180 ],
        wxLC_REPORT | wxLC_SINGLE_SEL
    );
    $self->{fsprlistview}
      ->InsertColumn( 0, "Existing process list", wxLIST_FORMAT_LEFT, 200 );
    my $count = 0;

    foreach (@processes) {
        $count++;
        $self->{fsprlistview}->InsertStringItem( $count, $_ );
    }
    $self->{btn_add} =
      Wx::Button->new( $self, wxID_ADD, "", [ 17, $height - 80 ] );

    $self->{btn_add}->Connect(
        -1, -1,
        &Wx::wxEVT_COMMAND_BUTTON_CLICKED,
        sub {
            my $dialog = Wx::TextEntryDialog->new(
                $self,
                "Enter process name",
                "Add process dialog", ""
            );

            if ( $dialog->ShowModal == wxID_OK ) {
                $self->{fsprlistview}
                  ->InsertStringItem( $count++, $dialog->GetValue );

            }
          }

    );

    $self->{btn_del} =
      Wx::Button->new( $self, wxID_DELETE, "", [ 119, $height - 80 ] );
    $self->{btn_del}->Connect(
        -1, -1,
        &Wx::wxEVT_COMMAND_BUTTON_CLICKED,
        sub {
            my $item = $self->{fsprlistview}->GetFocusedItem;
            if ( $self->{fsprlistview}->IsSelected($item) ) {
                $self->{fsprlistview}->DeleteItem($item);
                $count--;
            }
        }
    );

    $self->{btn_Ok} =
      Wx::Button->new( $self, wxID_OK, "", [ 17, $height - 40 ] );
    $self->{btn_Cancel} =
      Wx::Button->new( $self, wxID_CANCEL, "", [ 119, $height - 40 ] );
    $self->SetTitle("Settings");
    undef $height;
    undef @processes;
    return $self;
}

1;

package FSProj::GUI;

use Wx;
use Thread::Queue;
use base 'Wx::App';
my $tip;

sub OnExit {
    my $self = shift;
    $settings{enable} = $self->{state};
    &FSProj::Config::writeconf;
    $EXIT = !$EXIT;
    sleep 2;

    #kill 9, -$$;
}

sub OnInit {
    my $self = shift;

    $self->{state}   = $settings{enable};
    $self->{stdlg}   = FSProj::SettingsDialog->new();
    $self->{tbi}     = Wx::TaskBarIcon->new();
    $self->{tbicon}  = Wx::Icon->new();
    $self->{popmenu} = Wx::Menu->new();
    $self->OnSwState( $self->{state} );
    $self->MenuGen( $self->{state} );
    $self->{tbi}->Connect(
        -1, -1,
        &Wx::wxEVT_TASKBAR_LEFT_DOWN,
        sub {
            $self->{state} = !$self->{state};
            $self->{stdlg}->{fsenable}->SetValue( $self->{state} );
            $self->OnSwState( $self->{state} );
        }
    );
    $self->{tbi}->Connect( -1, -1, &Wx::wxEVT_TASKBAR_RIGHT_DOWN,
        sub { $self->{tbi}->PopupMenu( $self->{popmenu} ); } );
    $self->{winid_th}  = threads->create( \&FSProj::Logic::XWinID );
    $self->{ssaver_th} = threads->create(&FSProj::Logic::ScreenSaver);
    $self->{prloop_th} = threads->create( \&FSProj::Logic::ProjLoop );

}

sub OnSwState {
    my ( $this, $state ) = @_;
    my $path = $thispath . "/share/icons/fsproj";
    $tip = $state ? "Enabled" : "Disabled";
    if ($state) {
        $TQEnable->enqueue(1) unless $TQEnable->pending;
    }
    else {
        $TQEnable->dequeue if $TQEnable->pending;
    }
    $this->{tbicon}->LoadFile( "$path/$tip.xpm", &Wx::wxBITMAP_TYPE_XPM );
    $this->{tbi}->SetIcon( $this->{tbicon}, $tip );
    $settings{enable} = $state;
    &FSProj::Config::writeconf();
}

sub MenuGen {
    my ( $this, $state ) = @_;
    $this->{popmenu}->Append( &Wx::wxID_PROPERTIES, "" );
    $this->{popmenu}->AppendSeparator();
    $this->{popmenu}->Append( &Wx::wxID_ABOUT, "" );
    $this->{popmenu}->AppendSeparator();
    $this->{popmenu}->Append( &Wx::wxID_EXIT, "" );
    $this->{popmenu}->Connect(
        &Wx::wxID_EXIT,
        -1,
        &Wx::wxEVT_COMMAND_MENU_SELECTED,
        sub {
            $this->ExitMainLoop();
        }
    );
    $this->{popmenu}->Connect(
        &Wx::wxID_ABOUT,
        -1,
        &Wx::wxEVT_COMMAND_MENU_SELECTED,
        sub {
            my $abdialog = Wx::AboutDialogInfo->new();
            $abdialog->SetName("FullScreenProj.pl");
            $abdialog->SetVersion("$VERSION");
            $abdialog->SetDescription(
                "Crazy Fullscreen Detector & Screensaver Disabler");
            $abdialog->SetCopyright(
                'Â©2012, Igor Gritsenko <xenomorph@mail.univ.kiev.ua>');
            $abdialog->SetWebSite( "http://github/drone-pl/FullScreenProj.pl",
                "GitHub Repository" );
            Wx::AboutBox($abdialog);
        }
    );

    $this->{popmenu}->Connect(
        &Wx::wxID_PROPERTIES,
        -1,
        &Wx::wxEVT_COMMAND_MENU_SELECTED,
        sub {
            if ( $this->{stdlg}->ShowModal == &Wx::wxID_OK ) {
                $settings{timeout} = $this->{stdlg}->{timeout}->GetValue;
                $settings{gui}     = $this->{stdlg}->{fsgui}->GetValue;
                $this->{state}     = $this->{stdlg}->{fsenable}->GetValue;
                my @list = ();
                for (
                    my $i = 0 ;
                    $i < $this->{stdlg}->{fsprlistview}->GetItemCount ;
                    $i++
                  )
                {
                    push @list,
                      $this->{stdlg}->{fsprlistview}->GetItem($i)->GetText;
                }

                &FSProj::Utils::array2regexp( \@list, \$settings{regex} );
                $this->OnSwState( $this->{state} );
            }

        }
    );
}

1;

package FSProj::Main;

sub ActionHandle {
    my ( $signal, $pid ) = @_;
    FSProj::Utils::FSDebug( $signal . " fsproj PID:" . $pid . "\n" );
    kill $signal => $pid;
    undef $signal;
    undef $pid;
}

sub RunMainLoop {

    &FSProj::Utils::daemonize unless $DEBUG;
    if (shift) {
        my $app = FSProj::GUI->new;
        $app->MainLoop;
        undef $app;
    }
    else {
        threads->create( \&FSProj::Logic::XWinID );      #->detach;
        threads->create(&FSProj::Logic::ScreenSaver);    #->detach
        &FSProj::Logic::ProjLoop;
    }
}

if (@ARGV) {
    &FSProj::Config::ARGVparse();
}
else {
    &Pod::Usage::pod2usage(
        -verbose  => 99,
        -sections => "NAME|SYNOPSIS"
    );
}
&FSProj::Main::RunMainLoop( $settings{gui} );
&FSProj::Main::ActionHandle( 'TERM', -$$ );


__END__


=head1 OPTIONS

=over 8

=item B<--help>

Verbose description of command line options.

=back

=over 8

=item B<--version>

Shows current version.

=back

=over 8

=item B<--debug>

Prints a lot of info to terminal, don't use it unless debugging ;)

=back

=over 8

=item B<--no-gui>

Do not use the GUI (Default).

=back

=over 8

=item B<--gui>

Enable WxWidgets GUI. They are working currently almost perfect.

=back

=over 8

=item B<--timeout seconds>

Set timeout in seconds.

=back

=over 8

=item B<--disable>

Start inactive script.

=back

=over 8

=item B<--enable>

Start script and activate it (Default). 

=back

=over 8

=item B<--process-list>

Show current tracking process list.

=back

=over 8

=item B<--add-proc process>

Add process for tracking. There could be more than one process.

=back

=over 8

=item B<--del-proc process>

Delete process from tracking. There could be more than one process.

=back

=head1 ARGUMENTS

=over 8

=item B<start> 

Starts the script and  sets the specified options.

=back

=over 8

=item B<stop>  

Stops the script. All options will be ignored.

=back 

=over 8

=item B<status>  

Shows current status of the script.

=back 

=over 8

=item B<restart>  

Restarts the script.

=back 

Any other arguments will be ignored. 

=head1 DESCRIPTION

I<FullScreenProj.pl> a.k.a I<fsproj> is a small utility that detects various videoplayers in fullscreen mode and allows users to disable screensaver and/or screen power off via DPMS. Users can control its behaviour via command line.

Default timeout is set to 5 seconds, default process list includes vlc, mplayer, and flash plugin. 
Settings that were changed via command line, are saved in config file, thus they could be used for further usage. See L</EXAMPLES> for more info.

=head1 EXAMPLES

=over 8

=item C<fsproj>

Runs brief help and exit.

=back

=over 8

=item C<fsproj start>

Starts the utility with previous configuration.

=back

=over 8

=item C<fsproj stop>

Stops the utility.

=back

=over 8

=item C<fsproj --timeout 10 start>

Starts the utility with changed timeout and saves this timeout to config.

=back


=over 8

=item C<fsproj --add-proc totem --del-proc mplayer vlc restart>

Restarts the utility, removing mplayer and vlc from tracking list and adding totem to it. All changes are saved to config. 

=back


=over 8

=item C<fsproj --gui start>

Add WxWidgets GUI for easy use by novice users. It consist of tray icon and settings dialog box.

=back


=over 8

=item C<fsproj --process-list>

Shows info about currently tracked processes and exits. 

=back

=cut
