#!/usr/bin/env perl

use v5.10;
use strict;
use warnings;
use threads;
use Thread::Queue;
use Proc::ProcessTable;
use Cwd qw/abs_path/;

our $VERSION  = 0.6;
our %settings = ();
our $TQWinID  = Thread::Queue->new();
our $TQScrSvr = Thread::Queue->new();
our $TQEnable = Thread::Queue->new();
our $thispath = Cwd::abs_path($0) =~ s/(.*)\/.*\/.*/$1/r;

package FSProj::Utils;
use POSIX ('setsid');

sub regexp2array {
    return split( /\|/, shift =~ s/[\(\)\:\^\?]//gr );
}

sub array2regexp {
    return "(?^:(" . join( ')|(', @_ ) . "))";
}

sub processlist {
    my $cmndline = shift;
    $cmndline = qr/perl.*fsproj/ unless defined $cmndline;
    my @processlist = ();
    foreach ( @{ 'Proc::ProcessTable'->new->table; } ) {
        if ( $_->cmndline =~ $cmndline ) {
            push @processlist, $_->pid;
        }
    }
    return @processlist;
}

sub daemonize {
    die "Can't chdir to /: $!" unless chdir '/';
    umask 0;

    die "Can't read /dev/null: $!"     unless open STDIN,  '/dev/null';
    die "Can't write to /dev/null: $!" unless open STDOUT, '>/dev/null';
    die "Can't write to /dev/null: $!" unless open STDERR, '>/dev/null';
    die "Can't fork: $!" unless defined( my $pid = fork );
    exit if $pid;
    die "Can't start a new session: $!" unless setsid();
}
1;

package FSProj::Config;
use File::HomeDir;
use Getopt::Long;
use Pod::Usage;

my $home     = &home();
my $conffile = "$home/.config/FullscreenProj.pl/fsproj.conf";

sub readconf {
    if ( -e $conffile ) {
        open CONFIG, $conffile;
        while (<CONFIG>) {
            chomp;
            next if s/^(#.*|\s*)$//;
            my ( $var, $value ) = split( /\s*=\s*/, $_, 2 );
            $settings{$var} = $value;
        }
    }
    else {
        $settings{regex}   = qr/(libflash)/;
        $settings{timeout} = 50;
        $settings{gui}     = 0;
        $settings{enable}  = 1;
        $settings{action}  = "start";
        &writeconf;
    }
}

sub writeconf {
    $settings{action} = "start";
    mkdir $conffile =~ s/fsproj.conf//r;
    open CONFIG, ">", $conffile;
    foreach ( keys %settings ) {
        print CONFIG "$_ = $settings{$_}\n";
    }
    close CONFIG;
}

sub FSProcHandle {
    my ( $aproc, $dproc ) = @_;
    my %unproc = ();
    $unproc{$_} = 1
      foreach ( &FSProj::Utils::regexp2array( $settings{regex} ), @$aproc );
    delete $unproc{$_} foreach (@$dproc);
    @$aproc = sort keys %unproc;
    return &FSProj::Utils::array2regexp(@$aproc);
}

sub FSPlist {
    print "We are currently tracking such processes:\n";
    foreach ( &FSProj::Utils::regexp2array( $settings{regex} ) ) {
        print "\t\t\t$_\n";
    }
    exit;
}

sub ARGVparse {
    &FSProj::Config::readconf();
    my %tempsets;
    my @dprocs=qw/start status restart stop/;
    my @aprocs;
    GetOptions(
        \%tempsets,
        'timeout=i',
        'gui!', 'enable',
        'add-proc=s{,}' => \@aprocs,
        'del-proc=s{,}' => \@dprocs,
        'help'          => sub {
            &Pod::Usage::pod2usage(
                -verbose  => 99,
                -sections => "NAME|SYNOPSIS|OPTIONS|ARGUMENTS"
            );
        },
        'disable' => sub { $tempsets{enable} = 0 },
        'process-list' => sub { &FSProj::Config::FSPlist },

    );
    my @thisproc = &FSProj::Utils::processlist;
    given (@ARGV) {

        when ( "stop"    ~~ \@ARGV ) { $settings{action} = "stop"; }
        when ( "status"  ~~ \@ARGV ) { $settings{action} = "status"; }
        when ( "start"   ~~ \@ARGV ) { $settings{action} = "start"; }
        when ( "restart" ~~ \@ARGV ) { $settings{action} = "restart"; }
        default { $settings{action} = "restart"; }
    }
    if ($#thisproc) {

        foreach my $pid (@thisproc) {
            if ( $$ != $pid ) {
                given ( $settings{action} ) {
                    when (undef) { }
                    when (/(^start)|(status)/) {

                        print "fsproj is already running.\n";
                        print "More help: fsproj --help\n" if $_ eq "status";
                        exit;
                    }
                    when (/stop/) {
                        &FSProj::Main::ActionHandle( 'KILL', $pid );
                        exit;
                    }
                    when (/restart/) {
                        &FSProj::Main::ActionHandle( 'KILL', $pid );
                    }
                }
            }
        }

    }
    else {
        given ( $settings{action} ) {
            when (undef) { }
            when (/(stop)|(status)/) {
                print "fsproj is not running yet.\n";
                exit;

            }
        }
    }
    foreach ( keys %tempsets ) {
        $settings{$_} = $tempsets{$_};
    }
    $settings{regex} = &FSProj::Config::FSProcHandle( \@aprocs, \@dprocs )
      if @aprocs
          or @dprocs;
    &FSProj::Config::writeconf() unless $settings{action} eq "stop";
    $TQEnable->enqueue(1) if $settings{enable};
}

1;

package FSProj::Logic;
use Net::DBus;
$| = 1;
my $ON  = 'xset +dpms';
my $OFF = 'xset -dpms';

sub ScreenSaver {
    my $command;
    $command = q[system "xscreensaver-command -deactivate"]
      if &FSProj::Utils::processlist(qr"xscreensaver");
    $command =
q[Net::DBus->session->get_service("org.freedesktop.ScreenSaver")->get_object('/ScreenSaver')->SimulateUserActivity()]
      if &FSProj::Utils::processlist(qr"krunner");
    $command =
q[Net::DBus->session->get_service("org.gnome.ScreenSaver")->get_object('/')->SimulateUserActivity()]
      if &FSProj::Utils::processlist(qr"gnome-screensaver");
    return sub {
        if ( defined $command ) {
            while (1) {
                my $timeout = $settings{timeout};
                if ( $TQScrSvr->pending ) {
                    $timeout = $TQScrSvr->peek;
                    eval $command;
                    if ($@) {
                        warn $@;
                    }
                }
                sleep $timeout;
            }
        }
    };
}

sub CheckDPMS {
    my $DPMSPhrase = "DPMS is";
    chomp( my $state =
          qx|xset q \| grep "$DPMSPhrase" | =~ s/^\s+$DPMSPhrase\s+//r );
    return $state eq "Enabled";
}

sub ProjLoop {
    my $DPMSstate = &CheckDPMS;
    my @processes;
    while (1) {
        my ($winid) = $TQWinID->peek;
        while ( $TQWinID->pending ) {
            $TQWinID->dequeue;
        }

        until ( $TQWinID->pending ) {
            @processes = &FSProj::Utils::processlist( $settings{regex} );
            if ( qx#xprop -id $winid _NET_WM_PID# =~ s/[^\d]+//r ~~ \@processes
                and qx|xprop -id $winid _NET_WM_STATE| =~
                /_NET_WM_STATE_FULLSCREEN/ )
            {
                $TQScrSvr->enqueue( $settings{timeout} );
                system $OFF;
            }
            else {
                while ( $TQScrSvr->pending() ) {
                    $TQScrSvr->dequeue();
                }

                system $ON if $DPMSstate;
            }
            sleep $settings{timeout};
        }
    }
    close XPROP;
}

sub XWinID {
    open XPROP, 'xprop -spy -root _NET_ACTIVE_WINDOW |';
    while (<XPROP>) {
        if ( $TQEnable->pending ) {
            my $winid = s/.*?\# (.*)/$1/r;
            chomp $winid;
            $TQWinID->enqueue($winid);
        }
    }
}
1;

package FSProj::SettingsDialog;

use Wx qw[:everything];
use base qw(Wx::Dialog);

sub new {
    my ( $self, $parent, $id, $title, $pos, $size, $style, $name ) = @_;
    $parent = undef             unless defined $parent;
    $id     = -1                unless defined $id;
    $title  = ""                unless defined $title;
    $pos    = wxDefaultPosition unless defined $pos;
    my @processes = &FSProj::Utils::regexp2array( $settings{regex} );
    my $height    = 340 ;
    $size = [ 220, $height ];
    $name = "" unless defined $name;
    $style = wxDEFAULT_DIALOG_STYLE;
    $self =
      $self->SUPER::new( $parent, $id, $title, $pos, $size, $style, $name );
    $self->{fsenable} =
      Wx::CheckBox->new( $self, -1, "Tracking enabled", [ 27, 10 ], );
    $self->{fsenable}->SetValue( $settings{enable} );
    $self->{fsgui} =
      Wx::CheckBox->new( $self, -1, "Use WxWidgets GUI", [ 27, 36 ], );
    $self->{fsgui}->SetValue( $settings{gui} );
    $self->{tmlabel} =
      Wx::StaticText->new( $self, -1, "Timeout in seconds", [ 76, 66 ], );
    $self->{timeout} = Wx::SpinCtrl->new(
        $self, -1, "",
        [ 10, 66 ],
        [ 55, 20 ],
        wxSP_ARROW_KEYS, 0, 100, $settings{timeout}
    );
    $self->{fsprlistview} = Wx::ListView->new(
        $self, -1,
        [ 10,  90 ],
        [ 200,  $height-180],
        wxLC_REPORT | wxLC_SINGLE_SEL 
    );
    $self->{fsprlistview}->InsertColumn( 0, "Existing process list", wxLIST_FORMAT_LEFT, 200);
    my $count = 0;

    foreach (@processes) {
        $count++;
        $self->{fsprlistview}->InsertStringItem( $count, $_ );
    }
    $self->{btn_add} =
      Wx::Button->new( $self, wxID_ADD, "", [ 17, $height - 80 ] );

    $self->{btn_add}->Connect(
        -1, -1,
        &Wx::wxEVT_COMMAND_BUTTON_CLICKED, sub {
    my $dialog = Wx::TextEntryDialog->new
    ( $self, "Enter process name", "Wx::TextEntryDialog sample",
      "" );

  if( $dialog->ShowModal == wxID_OK ) {
    $self->{fsprlistview}->InsertStringItem( $count++, $dialog->GetValue  );

  } 
        }

    );

    $self->{btn_del} =
      Wx::Button->new( $self, wxID_DELETE, "", [ 119, $height - 80 ] );
    $self->{btn_del}->Connect(
        -1, -1,
        &Wx::wxEVT_COMMAND_BUTTON_CLICKED, sub { my $item=$self->{fsprlistview}->GetFocusedItem;
    if ( $self->{fsprlistview}->IsSelected($item)) {
        $self->{fsprlistview}->DeleteItem($item);
    }
}
    );


    $self->{btn_Ok} =
      Wx::Button->new( $self, wxID_OK, "", [ 17, $height - 40 ] );
    $self->{btn_Cancel} =
      Wx::Button->new( $self, wxID_CANCEL, "", [ 119, $height - 40 ] );
    $self->SetTitle("Settings");

    return $self;

}

1;

package FSProj::GUI;

use Wx;
use Thread::Queue;
use base 'Wx::App';
our ( $ID_SETTINGS, $ID_EXIT ) = ( 1001, 1010 );
my $tip;

sub OnExit {
    my $self = shift;
    $settings{enable} = $self->{state};
    &FSProj::Config::writeconf;
    #$self->{stdlg}->Destroy();
    #$self->{tbi}->Destroy();
    #$self->{popmenu}->Destroy();
}

sub OnInit {
    my $self = shift;

    $self->{state}   = $settings{enable};
    $self->{stdlg}   = FSProj::SettingsDialog->new();
    $self->{tbi}     = Wx::TaskBarIcon->new();
    $self->{tbicon}  = Wx::Icon->new();
    $self->{popmenu} = Wx::Menu->new();
    $self->OnSwState( $self->{state} );
    $self->MenuGen( $self->{state} );
    $self->{stdlg}->ShowModal;
    $self->{tbi}->Connect(
        -1, -1,
        &Wx::wxEVT_TASKBAR_LEFT_DOWN,
        sub {
            $self->{state} = !$self->{state};
            $self->{stdlg}->{fsenable}->SetValue( $self->{state} );
            $self->OnSwState( $self->{state} );
        }
    );
    $self->{tbi}->Connect( -1, -1, &Wx::wxEVT_TASKBAR_RIGHT_DOWN,
        sub { $self->{tbi}->PopupMenu( $self->{popmenu} ); } );
    return 1;
}

sub OnSwState {
    my ( $this, $state ) = @_;
    my $path = $thispath . "/share/icons/fsproj";
    $tip = $state ? "Enabled" : "Disabled";
    $this->{tbicon}->LoadFile( "$path/$tip.xpm", &Wx::wxBITMAP_TYPE_XPM );
    $this->{tbi}->SetIcon( $this->{tbicon}, $tip );
}

sub MenuGen {
    my ( $this, $state ) = @_;
    $this->{popmenu}->Append( $ID_SETTINGS, "Settings..." );
    $this->{popmenu}->AppendSeparator();
    $this->{popmenu}->Append( $ID_EXIT, "Exit\tCtrl-X" );
    $this->{popmenu}->Connect(
        $ID_EXIT, -1,
        &Wx::wxEVT_COMMAND_MENU_SELECTED,
        sub {
            $this->ExitMainLoop();
        }
    );
    $this->{popmenu}->Connect(
        $ID_SETTINGS,
        -1,
        &Wx::wxEVT_COMMAND_MENU_SELECTED,
        sub {
            if ( $this->{stdlg}->ShowModal == &Wx::wxID_OK ) {
                $settings{timeout} = $this->{stdlg}->{timeout}->GetValue;
                $settings{enable}  = $this->{stdlg}->{fsenable}->GetValue;
                my @list=();
                for (my $i=0;$i<$this->{stdlg}->{fsprlistview}->GetItemCount;$i++)
                {   
                    push @list, $this->{stdlg}->{fsprlistview}->GetItem($i)->GetText;
                }

                $settings{regex} = &FSProj::Utils::array2regexp(@list);
                $this->{state}     = $settings{enable};
                $this->OnSwState( $this->{state} );
                &FSProj::Config::writeconf();
            }

        }
    );
}

1;

package FSProj::Main;

sub ActionHandle {
    my ( $signal, $pid ) = @_;
    print "$signal fsproj PID:$pid\n";
    kill $signal => $pid;
}

sub RunMainLoop {
    #&FSProj::Utils::daemonize;
    if (shift) {
        my $app = FSProj::GUI->new;
        $app->MainLoop;
    }
    else {
        threads->create( \&FSProj::Logic::XWinID )->detach;
        threads->create(&FSProj::Logic::ScreenSaver)->detach;
        threads->create( \&FSProj::Logic::ProjLoop )->join;
    }
}

if (@ARGV) {
    &FSProj::Config::ARGVparse();
}
else {
    &Pod::Usage::pod2usage(
        -verbose  => 99,
        -sections => "NAME|SYNOPSIS"
    );
}

&FSProj::Main::RunMainLoop( $settings{gui} );

__END__

=pod

=head1 NAME

fsproj - Crazy Fullscreen Detector & Screensaver Disabler

=head1 SYNOPSIS

fsproj [options] <action>

Actions:

B<start stop restart status>

Options:

B<[--help] [--no-gui] [--gui] [--timeout seconds] [--disable] [--enable] [--process-list] [--add-proc process] [--del-proc process]>

Use --help for more information.

=head1 OPTIONS

=over 8

=item B<--help>

Verbose description of command line options.

=back

=over 8

=item B<--no-gui>

Do not use the GUI (Default).

=back

=over 8

=item B<--gui>

Enable WxWidgets GUI.

=back

=over 8

=item B<--timeout seconds>

Set timeout in seconds.

=back

=over 8

=item B<--disable>

Start inactive script.

=back

=over 8

=item B<--enable>

Start script and activate it (Default). 

=back

=over 8

=item B<--process-list>

Show current tracking process list.

=back

=over 8

=item B<--add-proc process>

Add process for tracking.

=back

=over 8

=item B<--del-proc process>

Delete process from tracking.

=back

=head1 ARGUMENTS

=over 8

=item B<start> 

Starts the script and  sets the specified options.

=back

=over 8

=item B<stop>  

Stops the script. All options will be ignored.

=back 

=over 8

=item B<status>  

Shows current status of the script.

=back 

=over 8

=item B<restart>  

Restarts the script.

=back 

Any other arguments will be ignored. 

=head1 DESCRIPTION

I<FullScreenProj.pl> a.k.a I<fsproj> is a small utility that detects various videoplayers in fullscreen mode and allows users to disable screensaver and/or screen power off via DPMS. Users can control its behaviour via command line.

Default timeout is set to 50 seconds, default process list includes vlc, mplayer, and flash plugin. 
Settings that were changed via command line, are saved in config file, thus they could be used for further usage. See L</EXAMPLES> for more info.

=head1 EXAMPLES

=over 8

=item C<fsproj>

Runs brief help and exit.

=back

=over 8

=item C<fsproj start>

Starts the utility with previous configuration.

=back

=over 8

=item C<fsproj stop>

Stops the utility.

=back

=over 8

=item C<fsproj --timeout 10 start>

Starts the utility with changed timeout and saves this timeout to config.

=back


=over 8

=item C<fsproj --add-proc totem --del-proc mplayer vlc restart>

Restarts the utility, removing mplayer and vlc from tracking list and adding totem to it. All changes are saved to config. 

=back


=over 8

=item C<fsproj --gui start>

Add WxWidgets GUI for easy use by novice users. Implemented, but bugged and not currently integrated in utility.

=back


=over 8

=item C<fsproj --process-list>

Shows info about currently tracked processes and exits. 

=back

=head1 AUTHOR

Igor Gritsenko <xenomorph@mail.univ.kiev.ua>

=head1 COPYRIGHT

Copyright (c) 2012 Igor Gritsenko <xenomorph@mail.univ.kiev.ua>

This program is free software; you can redistribute it and/or
                modify it under the same terms as Perl itself.

=cut
