#!/usr/bin/env perl

use strict;
use warnings;
use threads;
use Thread::Queue;
    
our $VERSION  = 0.5;
our %settings = ();
our $TQWinID  = Thread::Queue->new();
our $TQScrSvr = Thread::Queue->new();
our $TQEnable = Thread::Queue->new();

package Config;
use File::HomeDir;
use POSIX ('setsid');
use Getopt::Long;
use Pod::Usage;

my $home     = &home();
my $conffile = "$home/.config/FullscreenProj.pl/fsproj.conf";

sub readconf {
    if ( -e $conffile ) {
        open CONFIG, $conffile;
        while (<CONFIG>) {
            chomp;
            next if s/^(#.*|\s*)$//;
            my ( $var, $value ) = split( /\s*=\s*/, $_, 2 );
            $settings{$var} = $value;
        }
    }
    else {
        $settings{regex}   = qr/(libflash)/;
        $settings{timeout} = 50;
        $settings{gui}     = 0;
        $settings{state}   = 1;
        $settings{action}  = "start";
        &writeconf;
    }
}

sub writeconf {
    $settings{action} = "start";
    mkdir $conffile =~ s/fsproj.conf//r;
    open CONFIG, ">", $conffile;
    foreach ( keys %settings ) {
        print CONFIG "$_ = $settings{$_}\n";
    }
    close CONFIG;
}

sub daemonize {
    die "Can't chdir to /: $!" unless chdir '/';
    umask 0;

    die "Can't read /dev/null: $!"     unless open STDIN,  '/dev/null';
    die "Can't write to /dev/null: $!" unless open STDOUT, '>/dev/null';
    die "Can't write to /dev/null: $!" unless open STDERR, '>/dev/null';
    die "Can't fork: $!" unless defined( my $pid = fork );
    exit if $pid;
    die "Can't start a new session: $!" unless setsid();
}

sub FSProcHandle {
    my ( $aproc, $dproc ) = @_;
    my %unproc = ();
    $unproc{$_} = 1
      foreach ( &Config::regexp2array( $settings{regex} ), @$aproc );
    delete $unproc{$_} foreach (@$dproc);
    @$aproc = sort keys %unproc;
    return &Config::array2regexp(@$aproc);
}

sub regexp2array {
    return split( /\|/, shift =~ s/[\(\)\:\^\?]//gr );
}

sub array2regexp {
    return "(?^:(" . join( ')|(',  @_ ) . "))";
}

sub FSPlist {
    print "We are currently tracking such processes:\n\n";
    foreach ( &Config::regexp2array( $settings{regex} ) ) {
        print "\t\t\t$_\n";
    }
    print "\n";
    exit;
}

sub ARGVparse {
    my %tempsets;
    my @dprocs;
    my @aprocs;
    &Config::readconf();
    GetOptions(
        \%tempsets,
        'timeout=i',
        'gui!', 'enable',
        'add-proc=s{,}' => \@aprocs,
        'del-proc=s{,}' => \@dprocs,
        'help'          => sub {
            &Pod::Usage::pod2usage(
                -verbose  => 99,
                -sections => "NAME|SYNOPSIS|OPTIONS|ARGUMENTS"
            );
        },
        'disable' => sub { $tempsets{enable} = 0 },
        'process-list' => sub { &Config::FSPlist },

    );

    foreach my $key ( keys %tempsets ) {
        $settings{$key} = $tempsets{$key};
    }
    $settings{regex} = &Config::FSProcHandle( \@aprocs, \@dprocs )
    if ( @aprocs or @dprocs );
    $settings{action} = "save";
    if (@ARGV) {
        $settings{action} = pop @ARGV if ( "start" ~~ @ARGV || "stop" ~~ @ARGV );
    }
    &Config::writeconf() unless $settings{action} eq "stop";
    $TQEnable->enqueue(1) if $settings{enable};
} 

1;
package Logic;
use Net::DBus;
use Proc::ProcessTable;
$| = 1;
my $ON  = 'xset +dpms';
my $OFF = 'xset -dpms';

sub ScreenSaver {
    my $command;
    foreach ( @{ 'Proc::ProcessTable'->new->table; } ) {
        if ( $_->cmndline =~ /xscreensaver/ ) {
            $command = qq(system "xscreensaver-command -deactivate");
        }

        elsif ( $_->cmndline =~ /krunner/ ) {
            $command =
qq(Net::DBus->session->get_service("org.freedesktop.ScreenSaver")->get_object('/ScreenSaver')->SimulateUserActivity());
        }

        elsif ( $_->cmndline =~ /gnome-screensaver/ ) {
            $command =
qq(Net::DBus->session->get_service("org.gnome.ScreenSaver")->get_object('/')->SimulateUserActivity());
        }
    }
    return sub {
        while (1) {
            my $timeout=$settings{timeout};
            if ( $TQScrSvr->pending ) {
                $timeout=$TQScrSvr->peek();
                eval $command;
                if ($@) { warn $@; }
            }
            sleep $timeout;
        }
      }
}

sub CheckDPMS {
    my $DPMSPhrase = "DPMS is";
    chomp( my $state =
          ( qx|xset q \| grep "$DPMSPhrase" | =~ s/^\s+$DPMSPhrase\s+//r ) );
    return $state eq "Enabled";
}

sub ProjLoop {
    my $DPMSstate = &CheckDPMS;
    my @processes;
    while (1) {
        my ($winid) = $TQWinID->peek;
        while ( $TQWinID->pending() ) {
            $TQWinID->dequeue();
        }

        while ( !$TQWinID->pending() ) {

            @processes = ();
            foreach ( @{ 'Proc::ProcessTable'->new->table; } ) {
                if ( $_->cmndline =~ /$settings{regex}/ ) {
                    push @processes, $_->pid;
                }
            }
            if ( ( qx#xprop -id $winid _NET_WM_PID# =~ s/[^\d]+//r ) ~~
                @processes
                and qx|xprop -id $winid _NET_WM_STATE| =~
                /_NET_WM_STATE_FULLSCREEN/ )
            {
                $TQScrSvr->enqueue( $settings{timeout} );
                system $OFF;
            }
            else {
                while ( $TQScrSvr->pending() ) {
                    $TQScrSvr->dequeue();
                }

                system $ON if $DPMSstate;
            }
            sleep $settings{timeout};
        }
    }
    close XPROP;
}

sub XWinID {
    open XPROP, 'xprop -spy -root _NET_ACTIVE_WINDOW |';
    while (<XPROP>) {
        if($TQEnable->pending()) {
            my $winid = s/.*?\# (.*)/$1/r;
            chomp $winid;
            $TQWinID->enqueue($winid);
        }
    }
}
1;
package FSProj;
use Proc::ProcessTable;

sub ActionHandle {
    my ( $signal, $pid ) = @_;
    print "$signal fsproj PID:$pid\n";
    kill $signal => $pid;
}

sub RunMainLoop {

    &Config::daemonize;
    threads->create( \&Logic::XWinID )->detach();
    threads->create(&Logic::ScreenSaver)->detach();
    threads->create( \&Logic::ProjLoop )->join();

}
if (@ARGV) { &Config::ARGVparse(); }
else {
    &Pod::Usage::pod2usage(
        -verbose  => 99,
        -sections => "NAME|SYNOPSIS"
    );
}

foreach ( @{ 'Proc::ProcessTable'->new->table; } ) {
    if ( ( $_->cmndline =~ /perl.*fsproj/ ) and ( $_->pid != $$ ) ) {
        &FSProj::ActionHandle( 'KILL', $_->pid );
        exit if $settings{action} eq "stop";
        print $settings{action};
        $settings{action}="start";
    }
}
exit if $settings{action} ne "start";
&FSProj::RunMainLoop();

__END__

=pod

=head1 NAME

fsproj - Crazy Fullscreen Detector & Screensaver Disabler

=head1 SYNOPSIS

fsproj [options] <action>

Actions:

B<start stop>

Options:

B<[--help] [--no-gui] [--gui] [--timeout seconds] [--disable] [--enable] [--process-list] [--add-proc process] [--del-proc process]>

Use --help for more information.

=head1 OPTIONS

=over 8

=item B<--help>

Verbose description of command line options.

=back

=over 8

=item B<--no-gui>

Do not use the GUI (Default).

=back

=over 8

=item B<--gui>

Enable WxWidgets GUI.

=back

=over 8

=item B<--timeout seconds>

Set timeout in seconds.

=back

=over 8

=item B<--disable>

Start inactive script.

=back

=over 8

=item B<--enable>

Start script and activate it (Default). 

=back

=over 8

=item B<--process-list>

Show current tracking process list.

=back

=over 8

=item B<--add-proc process>

Add process for tracking.

=back

=over 8

=item B<--del-proc process>

Delete process from tracking.

=back

=head1 ARGUMENTS

=over 8

=item B<start> 

Starts the script, if not started yet, and  sets the specified options.

=back

=over 8

=item B<stop>  

Stops the script. All options will be ignored.

=back 

Any other arguments will be ignored. If neither B<start> nor B<stop> arguments are applied, the script saves parameters; if it was already running, restarts the utility.


=head1 DESCRIPTION

I<FullScreenProj.pl> a.k.a I<fsproj> is a small utility that detects various videoplayers in fullscreen mode and allows users to disable screensaver and/or screen power off via DPMS. Users can control its behaviour via command line.

Default timeout is set to 50 seconds, default process list includes vlc, mplayer, and flash plugin. 
Settings that were changed via command line, are saved in config file, thus they could be used for further usage. See L</EXAMPLES> for more info.

=head1 EXAMPLES

=over 8

=item C<fsproj>

Runs brief help and exit.

=back

=over 8

=item C<fsproj start>

Starts or restarts the utility with previous configuration.

=back

=over 8

=item C<fsproj stop>

Stops the utility.

=back

=over 8

=item C<fsproj --timeout 10 start>

Starts or restarts the utility, with changed timeout and saves this timeout to config.

=back


=over 8

=item C<fsproj --add-proc totem --del-proc mplayer vlc start>

Starts or restarts the utility, removing mplayer and vlc from tracking list and adding totem to it. All changes are saved to config. 

=back


=over 8

=item C<fsproj --gui start>

Add WxWidgets GUI for easy use by novice users. Implemented, but bugged and not currently integrated in utility.

=back


=over 8

=item C<fsproj --process-list>

Shows info about currently tracked processes and exits. 

=back


=over 8

=item C<fsproj --disable>

Disables processing if started and saves this parameter to config file. It won't start script if it wasn't running. If script is running, this command don't stop it, it will wait until C<fsproj --enable> or C<fsproj stop>.

=back


=head1 AUTHOR

Igor Gritsenko <xenomorph@mail.univ.kiev.ua>

=head1 COPYRIGHT

Copyright (c) 2012 Igor Gritsenko <xenomorph@mail.univ.kiev.ua>

This program is free software; you can redistribute it and/or
                modify it under the same terms as Perl itself.

=cut
